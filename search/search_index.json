{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SamenVattingen Van Danillo Ladu","title":"Home"},{"location":"#samenvattingen-van-danillo-ladu","text":"","title":"SamenVattingen Van Danillo Ladu"},{"location":"jefCrud/","text":"Jef - Create Update Edit Delete Applsrv.programs Applsrv.desktop.functions Desktop.functions Common Programs - Programma/Colom Omschrijving DataLogic - Provider Service AS400 en andere services MainPanel GUI Constante df - DataFormatter Function - Main classe bij het opstarten (DI) Adapters resolver crud events Search , Update , Insert Attribute rm - Resolve method TranslationTable 1: Update programma !!!!!JUISTE NAAM extends ProgramDescription record opstellen (Type, key_version, dataset) key versie mee geven zie rpg Dataset is onze formatter public class EXORDHDR01 extends ProgramDescription { private static final int KEY_VERSION = 1; public EXORDHDR01() { // keyRecord, AS400DataSet dataRecord type super(RESOLVER, EXORDHDR01::keyRecord, EXORDHDRR1::record); // Auto-generated constructor stub } private static AS400DataSet keyRecord() { return AS400DataSet.builder(KEY_VERSION).with(new WMSCompany(), new Order()).build(); } } 2: DataSet Opstellen van Resolver Static AS400DataSet builder verwacht onze data version key van rpg + alle atributen aan onze rpg kant public final class EXORDHDRR1 { private static final int RECORD_VERSION = 1; private EXORDHDRR1() { // Utility class } public static AS400DataSet record() { return builder(RECORD_VERSION).with(new Order(), new OrderDate(), new DeliveryDate(), new Carrier().makeRequired(false), new OrderStatus(), new IsRushOrder()).build(); } } 3: Rysync programma !!!!!JUISTE NAAM extends ProgramDescription record opstellen (Type, key_version, dataset) key versie mee geven zie rpg Dataset is onze formatter public class EXORDHDR21 extends ProgramDescription { private static final int KEY_VERSION = 1; public EXORDHDR21() { super(RESYNC, EXORDHDR21::keyRecord, EXORDHDRD1::dataSet002); } private static AS400DataSet keyRecord() { return AS400DataSet.builder(KEY_VERSION) .with(new WMSCompany(), new Order()) .build(); } } 4: Providers toevoegen aan DataLogic provider toevoegen add master details voeg resolver toe en voeg functie toe getOrderResyncRow om van het update een data record te vragen na onze insert van de update // update order Provider orderUpdate = new AS400Provider(this, UPDATE_DATATABLENAME, EXORDHDR01.class); // voor de index row te vinden orderUpdateOrderOrdinal = orderUpdate.getColumnOrdinal(Order.NAME); // auto refresh alleen als je wit triggeren en niet automatishe // allways refresh -> geen parameter refresht die ook addMasterDetailLink(orderList, orderUpdate, false); addProvider(orderUpdate); addResolver(orderUpdate.createResolver()); // resync orderResync = new AS400Provider(this, RESYNCER_DATATABLENAME, EXORDHDR21.class); // nodig voor update en delete , bij insert moeten we andere manier doen addMasterDetailLink(orderUpdate, orderResync, false); addProvider(orderResync); Object[] getOrderResyncRow(Object[] orderUpdateRow) throws FunctionException { orderResync.setParameter(Order.NAME, orderUpdateRow[orderUpdateOrderOrdinal]); // call order provider orderResync.refresh(); return orderResync.getCurrentRow(); } 5: Adapters en events toevoegen aan Function InsertEventAdapter InsertDFEA UpdateEventAdapter UpdateDFEA DeleteDFEA toevoegen aan one function adapters.add(new InsertEventAdapter(orderUpdate, orderResolver, orderList)); // update adapters.add(new UpdateEventAdapter(orderUpdate, orderResolver, orderList)); // delete adapters.add(new DeleteDFEA(orderUpdate, orderResolver, orderList, deriveUIName(UPDATE_PANELNAME))); private final class InsertEventAdapter extends InsertDFEA { private InsertEventAdapter(Provider provider, Resolver resolver, Provider masterProvider) { super(provider, resolver, masterProvider, UPDATE_PANELNAME); } // van de update een datarecord vragen en voegt die toe aan die provider // na onze insert via de update // record toevoegen in onze resync provider -> parameter @Override public Object[] getMasterRow(Object[] providerRow) throws FunctionException { return getDataContext().getOrderResyncRow(providerRow); } } private final class UpdateEventAdapter extends UpdateDFEA { private UpdateEventAdapter(Provider provider, Resolver resolver, Provider masterProvider) { super(provider, resolver, masterProvider, UPDATE_PANELNAME); } @Override public Object[] getMasterRow(Object[] providerRow) throws FunctionException { return getDataContext().getOrderResyncRow(providerRow); } } 6: Update class Update extends StandardDialogPanel constructor met DialogType appendLabelAndComponent @SuppressWarnings(\"serial\") public final class Update extends StandardDialogPanel { public Update(DialogType type) { super(type); Boolean readOnly = type == DELETE; JefMigBuilder builder = new JefMigBuilder(MigLayoutFactory.create(MigLayoutFactory.Type.ONE_DATA_COLUMN), UPDATE_DATATABLENAME); builder.appendLabeledComponent(type == INSERT ? JEFTEXT : JEFLABEL, Order.NAME); builder.appendLabeledComponent(readOnly ? JEFLABEL : JEFDATE, OrderDate.NAME); builder.appendLabeledComponent(readOnly ? JEFLABEL : JEFDATE, DeliveryDate.NAME); builder.appendLabeledComponent(readOnly ? JEFLABEL : JEFTEXT, Carrier.NAME); builder.appendLabeledComponent(readOnly ? JEFLABEL : JEFCOMBOBOX, OrderStatus.NAME); builder.appendLabeledComponent(JEFCHECKBOX, IsRushOrder.NAME).setEnabled(!readOnly); add(builder.getJefPanel()); } }","title":"Create Update Edit Delete"},{"location":"jefCrud/#jef-create-update-edit-delete","text":"Applsrv.programs Applsrv.desktop.functions Desktop.functions Common Programs - Programma/Colom Omschrijving DataLogic - Provider Service AS400 en andere services MainPanel GUI Constante df - DataFormatter Function - Main classe bij het opstarten (DI) Adapters resolver crud events Search , Update , Insert Attribute rm - Resolve method TranslationTable","title":"Jef -  Create Update Edit Delete"},{"location":"jefCrud/#_1","text":"","title":""},{"location":"jefCrud/#1-update-programma","text":"!!!!!JUISTE NAAM extends ProgramDescription record opstellen (Type, key_version, dataset) key versie mee geven zie rpg Dataset is onze formatter public class EXORDHDR01 extends ProgramDescription { private static final int KEY_VERSION = 1; public EXORDHDR01() { // keyRecord, AS400DataSet dataRecord type super(RESOLVER, EXORDHDR01::keyRecord, EXORDHDRR1::record); // Auto-generated constructor stub } private static AS400DataSet keyRecord() { return AS400DataSet.builder(KEY_VERSION).with(new WMSCompany(), new Order()).build(); } }","title":"1: Update programma"},{"location":"jefCrud/#2-dataset-opstellen-van-resolver","text":"Static AS400DataSet builder verwacht onze data version key van rpg + alle atributen aan onze rpg kant public final class EXORDHDRR1 { private static final int RECORD_VERSION = 1; private EXORDHDRR1() { // Utility class } public static AS400DataSet record() { return builder(RECORD_VERSION).with(new Order(), new OrderDate(), new DeliveryDate(), new Carrier().makeRequired(false), new OrderStatus(), new IsRushOrder()).build(); } }","title":"2: DataSet Opstellen van Resolver"},{"location":"jefCrud/#3-rysync-programma","text":"!!!!!JUISTE NAAM extends ProgramDescription record opstellen (Type, key_version, dataset) key versie mee geven zie rpg Dataset is onze formatter public class EXORDHDR21 extends ProgramDescription { private static final int KEY_VERSION = 1; public EXORDHDR21() { super(RESYNC, EXORDHDR21::keyRecord, EXORDHDRD1::dataSet002); } private static AS400DataSet keyRecord() { return AS400DataSet.builder(KEY_VERSION) .with(new WMSCompany(), new Order()) .build(); } }","title":"3: Rysync programma"},{"location":"jefCrud/#4-providers-toevoegen-aan-datalogic","text":"provider toevoegen add master details voeg resolver toe en voeg functie toe getOrderResyncRow om van het update een data record te vragen na onze insert van de update // update order Provider orderUpdate = new AS400Provider(this, UPDATE_DATATABLENAME, EXORDHDR01.class); // voor de index row te vinden orderUpdateOrderOrdinal = orderUpdate.getColumnOrdinal(Order.NAME); // auto refresh alleen als je wit triggeren en niet automatishe // allways refresh -> geen parameter refresht die ook addMasterDetailLink(orderList, orderUpdate, false); addProvider(orderUpdate); addResolver(orderUpdate.createResolver()); // resync orderResync = new AS400Provider(this, RESYNCER_DATATABLENAME, EXORDHDR21.class); // nodig voor update en delete , bij insert moeten we andere manier doen addMasterDetailLink(orderUpdate, orderResync, false); addProvider(orderResync); Object[] getOrderResyncRow(Object[] orderUpdateRow) throws FunctionException { orderResync.setParameter(Order.NAME, orderUpdateRow[orderUpdateOrderOrdinal]); // call order provider orderResync.refresh(); return orderResync.getCurrentRow(); }","title":"4: Providers toevoegen aan DataLogic"},{"location":"jefCrud/#5-adapters-en-events-toevoegen-aan-function","text":"InsertEventAdapter InsertDFEA UpdateEventAdapter UpdateDFEA DeleteDFEA toevoegen aan one function adapters.add(new InsertEventAdapter(orderUpdate, orderResolver, orderList)); // update adapters.add(new UpdateEventAdapter(orderUpdate, orderResolver, orderList)); // delete adapters.add(new DeleteDFEA(orderUpdate, orderResolver, orderList, deriveUIName(UPDATE_PANELNAME))); private final class InsertEventAdapter extends InsertDFEA { private InsertEventAdapter(Provider provider, Resolver resolver, Provider masterProvider) { super(provider, resolver, masterProvider, UPDATE_PANELNAME); } // van de update een datarecord vragen en voegt die toe aan die provider // na onze insert via de update // record toevoegen in onze resync provider -> parameter @Override public Object[] getMasterRow(Object[] providerRow) throws FunctionException { return getDataContext().getOrderResyncRow(providerRow); } } private final class UpdateEventAdapter extends UpdateDFEA { private UpdateEventAdapter(Provider provider, Resolver resolver, Provider masterProvider) { super(provider, resolver, masterProvider, UPDATE_PANELNAME); } @Override public Object[] getMasterRow(Object[] providerRow) throws FunctionException { return getDataContext().getOrderResyncRow(providerRow); } }","title":"5: Adapters en events toevoegen aan Function"},{"location":"jefCrud/#6-update-class","text":"Update extends StandardDialogPanel constructor met DialogType appendLabelAndComponent @SuppressWarnings(\"serial\") public final class Update extends StandardDialogPanel { public Update(DialogType type) { super(type); Boolean readOnly = type == DELETE; JefMigBuilder builder = new JefMigBuilder(MigLayoutFactory.create(MigLayoutFactory.Type.ONE_DATA_COLUMN), UPDATE_DATATABLENAME); builder.appendLabeledComponent(type == INSERT ? JEFTEXT : JEFLABEL, Order.NAME); builder.appendLabeledComponent(readOnly ? JEFLABEL : JEFDATE, OrderDate.NAME); builder.appendLabeledComponent(readOnly ? JEFLABEL : JEFDATE, DeliveryDate.NAME); builder.appendLabeledComponent(readOnly ? JEFLABEL : JEFTEXT, Carrier.NAME); builder.appendLabeledComponent(readOnly ? JEFLABEL : JEFCOMBOBOX, OrderStatus.NAME); builder.appendLabeledComponent(JEFCHECKBOX, IsRushOrder.NAME).setEnabled(!readOnly); add(builder.getJefPanel()); } }","title":"6: Update class"},{"location":"jefViewOnly/","text":"Jef - Vieuw Only Applsrv.programs Applsrv.desktop.functions Desktop.functions Common Programs - Programma/Colom Omschrijving DataLogic - Provider Service AS400 en andere services MainPanel GUI Constante df - DataFormatter Function - Main classe bij het opstarten (DI) Adapters resolver crud events Search , Update , Insert Attribute rm - Resolve method TranslationTable 1: Programma Lijst maken !!!!!JUISTE NAAM extends ProgramDescription record opstellen (Type, key_version, dataset) key versie mee geven zie rpg Dataset is onze formatter public final class EXORDHDR11 extends ProgramDescription { private static final int KEY_VERSION = 1; public EXORDHDR11() { super(LIST, EXORDHDR11::keyRecord, EXORDHDRD1::dataSet002); } private static AS400DataSet keyRecord() { return AS400DataSet.builder(KEY_VERSION).with(new WMSCompany()).build(); } } 2: DataSet Opstellen Static AS400DataSet builder verwacht onze data version key van rpg + alle atributen aan onze rpg kant public final class EXORDHDRD1 { private static final int DATA_VERSION = 1; private EXORDHDRD1() {} public static AS400DataSet dataSet002() { return AS400DataSet.builder(DATA_VERSION) .with(new Order(), new OrderDate(), new DeliveryDate(), new Carrier(), new OrderStatus(), new IsRushOrder()) .build(); } } 3: Atributen opstellen static final name opstellen met constructor lengte meegeven zelfde lengte als de rpg attribute extends Text, Date, Numeric public final class AdressType extends Text { public static final String NAME = \"ADRESS_TYPE\"; public static final int LENGTH = 3; public static final String CODE_KEY = \"EXADRTYP\"; /** * Constructor with the default attribute name. */ public AdressType() { this(NAME); } /** * Constructor with a specific attribute name * * @param name * name of the attribute. */ public AdressType(String name) { super(name, LENGTH); } } 4: DataLogic Extend DataContext !!!! Providers Toevoegen Set parameter voor je company Gebruik van constenten die al gekend zijn met eventueel prefixen nieuwe provider toevoegen aan je DataContext Providers @Override start voor je data te refreshen (OR 11) final class DataLogic extends DataContext { private Provider orderList; DataLogic(ApplicationManager applicationManager, String company) throws FunctionException { super(applicationManager); orderList = new AS400Provider(this, LIST_DATATABLENAME, EXORDHDR11.class); orderList.setParameter(WMSCompany.NAME, company); addProvider(orderList); } @Override public void start() throws FunctionException { orderList.refresh(); } } 5: Function Extend GUIFunctionContext @override createDataContext WMSCompany get key toevoegen aan de new DataLogic object Toevoegen aan de menu (package com.essers.mstl.training.applsrv.desktop.functions.order.management.danlad.function) public final class Function extends GUIFunctionContext { public Function(ApplicationManager applicationManager, GUIFunctionContext parent, Parameter[] parameters) { super(applicationManager, parent, parameters); } @Override public DataContext createDataContext(ApplicationManager applicationManager) throws FunctionException { return new DataLogic(applicationManager, (String) WMSCompany.getParameter(this).getKey()); } } 6: Constanten aanmaken + translation table aanmaken van constanten voor doorheen je aplicatie gebruik van jef constanten + prefixen ook constanten aan maken in je functuions + translation table public final class TranslationTable extends ResourceBundle { private static final String UNTILL = \"Untill\"; private static final String VERSION = \"Version\"; private static final TranslationTable INSTANCE = new TranslationTable(); private static final String[][] CONTENTS = new String[][] { { Order.NAME, \"Order\" }, { Batch.NAME, \"Batch\" }, { Carrier.NAME, \"Carrier\" }, { CustomerCity.NAME, \"City\" }, { TotalOrdersToInvoice.NAME, \"Orders to Invoice\" } }; public static ResourceBundle getInstance() { return INSTANCE; } @Override public Object[][] getContents() { return copy(CONTENTS); } @Override public ResourceBundle[] getSuperResourceBundles() { return new ResourceBundle[] { com.essers.mstl.system.TranslationTable.getInstance() }; } } 7: MainPanel Extend FunctionMainPanels Koppelen van de naam Databel uit je provider aan Jef Grid @SuppressWarnings(\"serial\") public final class MainPanel extends FunctionMainPanel { public MainPanel() { add(new JefGrid(LIST_DATATABLENAME)); } } 8: Toevoegen Menu Override createMenuBar JefMenuBar MenuFactory aan de menubar toevoegen met list control grid control en actie control @Override public JefMenuBar createMenuBar() { JefMenuBar menuBar = new JefMenuBar(); // add file menu JefMenu menu = MenuFactory.create(MenuFactory.Type.FILE); // menu.add(MenuItemFactory.createListControls(false)); menu.add(MenuItemFactory.createListControls(null, true, false, false)); menu.addSeparator(); menu.add(MenuItemFactory.createGridControls(MainPanel.class, orderGrid)); menu.addSeparator(); menu.add(MenuItemFactory.create(MenuItemFactory.Type.CLOSE)); menuBar.add(menu); // add edit menu menu = MenuFactory.create(MenuFactory.Type.EDIT); menu.add(MenuItemFactory.createActionControls(new MenuItemFactory.Type[] { MenuItemFactory.Type.INSERT, MenuItemFactory.Type.UPDATE, MenuItemFactory.Type.DELETE })); menuBar.add(menu); menu.addSeparator(); return menuBar; } 9: Search Toevoegen U lijst programma voorzien met de zoek atributen Constructor van function setInitialFunctionEvent(new FunctionEvent(SEARCH_EVENTCODE)) toevoegen configureFunctionEventAdapters overschrijven + aproviders toevoegen en EventAdaptersFactory toevoegen orderlist in je datalogic set blocked zetten + refresh afzetten + provider toevoegen(EventAdaptersFactory) EXORDHDR11 private static AS400DataSet keyRecord() { return AS400DataSet.builder(KEY_VERSION).with(new WMSCompany(), new Order()).build(); } Function public Function(ApplicationManager applicationManager, GUIFunctionContext parent, Parameter[] parameters) { super(applicationManager, parent, parameters); // search event kan meedere event verwachten setInitialFunctionEvent(new FunctionEvent(SEARCH_EVENTCODE)); } @Override protected void configureFunctionEventAdapters(Collection<eventadapter> adapters) { super.configureFunctionEventAdapters(adapters); Provider orderList = getDataContext().getProvider(LIST_DATATABLENAME); Provider orderParameters = getDataContext().getProvider(PARAMETER_DATATABLENAME); adapters.addAll(EventAdaptersFactory.createList(orderParameters, deriveUIName(SEARCH_PANELNAME), orderList)); } DataLogic // verpligting van zoek ceteria orderList.setBlocked(true); addProvider(new ParameterProvider(this, PARAMETER_DATATABLENAME, orderList)); @Override public void start() throws FunctionException { // Deze is niet nodig omdat we de orderlist blokeren // orderList.refresh(); } 10 : Criteria panel / toolbar / panel toevoegen aan de GUI Datalogic ColumnValuesProvider toevoegen voor onze RefreshPicklistFEA ReorderFEA en FilterFEA op de orderlist in onze function zoek adappter toevoegen configureFunctionEventAdapters overschrijven plus de andere addapters zelf toevoegen (driveUIName) main panel addLocalOrderingColumns, addLocalMultiFilteringColumn, addLocalSingleFilteringColumn op onze get table van onze order createria panel toevoegen aan de toolbar DataLogic addProvider(new ColumnValuesProvider(this, CARRIER_FILTER_DATATABLENAME, orderList, Carrier.NAME)); addProvider(new ColumnValuesProvider(this, IS_RUSH_ORDER_FILTER_DATATABLENAME, orderList, IsRushOrder.NAME)); Function // reorder event adapters.add(new ReorderFEA(orderList, null, null)); // event add filter adapters.add(new FilterFEA(orderList, null, null)); // new refresh pickup event // we moeten providers toevoegen in onze data logic adapters.add(new RefreshPicklistFEA()); MainPanel // sorteren op header van grid van je Attribute orderGrid.getTable() .getTableHeader() .addLocalOrderingColumns(new String[] { OrderDate.NAME, DeliveryDate.NAME }); // filteren met Multy Filter orderGrid.getTable() .getTableHeader() .addLocalMultiFilteringColumn(LIST_DATATABLENAME, Carrier.NAME, new PickListDescription(CARRIER_FILTER_DATATABLENAME, Carrier.NAME, Carrier.NAME)); // filteren met Single Filter orderGrid.getTable() .getTableHeader() .addLocalSingleFilteringColumn(LIST_DATATABLENAME, IsRushOrder.NAME, new PickListDescription(IS_RUSH_ORDER_FILTER_DATATABLENAME, IsRushOrder.NAME, IsRushOrder.NAME), true, ASTERISK, NULL); // toolbar toevoegen met criteria toevoegen add(JefToolBar.joinToolBarWithCriteria(createOrderListToolBar(), createCriteriaPanel()), NORTH); private static CriteriaPanel createCriteriaPanel() { CriteriaPanel panel = new CriteriaPanel(); // zoeken altijd via zoekscherm // Jefmigbuilder voor zowel zoeken als label tonen op je DATATABELNAAM JefMigBuilder builder = new JefMigBuilder(MigLayoutFactory.create(MigLayoutFactory.Type.WITHOUT_INSETS), PARAMETER_DATATABLENAME, panel); builder.appendLabelAndComponent(DataComponentFactory.Type.JEFLABEL, Order.NAME); return panel; }","title":"View only"},{"location":"jefViewOnly/#jef-vieuw-only","text":"Applsrv.programs Applsrv.desktop.functions Desktop.functions Common Programs - Programma/Colom Omschrijving DataLogic - Provider Service AS400 en andere services MainPanel GUI Constante df - DataFormatter Function - Main classe bij het opstarten (DI) Adapters resolver crud events Search , Update , Insert Attribute rm - Resolve method TranslationTable","title":"Jef - Vieuw Only"},{"location":"jefViewOnly/#_1","text":"","title":""},{"location":"jefViewOnly/#1-programma-lijst-maken","text":"!!!!!JUISTE NAAM extends ProgramDescription record opstellen (Type, key_version, dataset) key versie mee geven zie rpg Dataset is onze formatter public final class EXORDHDR11 extends ProgramDescription { private static final int KEY_VERSION = 1; public EXORDHDR11() { super(LIST, EXORDHDR11::keyRecord, EXORDHDRD1::dataSet002); } private static AS400DataSet keyRecord() { return AS400DataSet.builder(KEY_VERSION).with(new WMSCompany()).build(); } }","title":"1: Programma Lijst maken"},{"location":"jefViewOnly/#2-dataset-opstellen","text":"Static AS400DataSet builder verwacht onze data version key van rpg + alle atributen aan onze rpg kant public final class EXORDHDRD1 { private static final int DATA_VERSION = 1; private EXORDHDRD1() {} public static AS400DataSet dataSet002() { return AS400DataSet.builder(DATA_VERSION) .with(new Order(), new OrderDate(), new DeliveryDate(), new Carrier(), new OrderStatus(), new IsRushOrder()) .build(); } }","title":"2: DataSet Opstellen"},{"location":"jefViewOnly/#3-atributen-opstellen","text":"static final name opstellen met constructor lengte meegeven zelfde lengte als de rpg attribute extends Text, Date, Numeric public final class AdressType extends Text { public static final String NAME = \"ADRESS_TYPE\"; public static final int LENGTH = 3; public static final String CODE_KEY = \"EXADRTYP\"; /** * Constructor with the default attribute name. */ public AdressType() { this(NAME); } /** * Constructor with a specific attribute name * * @param name * name of the attribute. */ public AdressType(String name) { super(name, LENGTH); } }","title":"3: Atributen opstellen"},{"location":"jefViewOnly/#4-datalogic","text":"Extend DataContext !!!! Providers Toevoegen Set parameter voor je company Gebruik van constenten die al gekend zijn met eventueel prefixen nieuwe provider toevoegen aan je DataContext Providers @Override start voor je data te refreshen (OR 11) final class DataLogic extends DataContext { private Provider orderList; DataLogic(ApplicationManager applicationManager, String company) throws FunctionException { super(applicationManager); orderList = new AS400Provider(this, LIST_DATATABLENAME, EXORDHDR11.class); orderList.setParameter(WMSCompany.NAME, company); addProvider(orderList); } @Override public void start() throws FunctionException { orderList.refresh(); } }","title":"4: DataLogic"},{"location":"jefViewOnly/#5-function","text":"Extend GUIFunctionContext @override createDataContext WMSCompany get key toevoegen aan de new DataLogic object Toevoegen aan de menu (package com.essers.mstl.training.applsrv.desktop.functions.order.management.danlad.function) public final class Function extends GUIFunctionContext { public Function(ApplicationManager applicationManager, GUIFunctionContext parent, Parameter[] parameters) { super(applicationManager, parent, parameters); } @Override public DataContext createDataContext(ApplicationManager applicationManager) throws FunctionException { return new DataLogic(applicationManager, (String) WMSCompany.getParameter(this).getKey()); } }","title":"5: Function"},{"location":"jefViewOnly/#6-constanten-aanmaken-translation-table","text":"aanmaken van constanten voor doorheen je aplicatie gebruik van jef constanten + prefixen ook constanten aan maken in je functuions + translation table public final class TranslationTable extends ResourceBundle { private static final String UNTILL = \"Untill\"; private static final String VERSION = \"Version\"; private static final TranslationTable INSTANCE = new TranslationTable(); private static final String[][] CONTENTS = new String[][] { { Order.NAME, \"Order\" }, { Batch.NAME, \"Batch\" }, { Carrier.NAME, \"Carrier\" }, { CustomerCity.NAME, \"City\" }, { TotalOrdersToInvoice.NAME, \"Orders to Invoice\" } }; public static ResourceBundle getInstance() { return INSTANCE; } @Override public Object[][] getContents() { return copy(CONTENTS); } @Override public ResourceBundle[] getSuperResourceBundles() { return new ResourceBundle[] { com.essers.mstl.system.TranslationTable.getInstance() }; } }","title":"6: Constanten aanmaken + translation table"},{"location":"jefViewOnly/#7-mainpanel","text":"Extend FunctionMainPanels Koppelen van de naam Databel uit je provider aan Jef Grid @SuppressWarnings(\"serial\") public final class MainPanel extends FunctionMainPanel { public MainPanel() { add(new JefGrid(LIST_DATATABLENAME)); } }","title":"7: MainPanel"},{"location":"jefViewOnly/#8-toevoegen-menu","text":"Override createMenuBar JefMenuBar MenuFactory aan de menubar toevoegen met list control grid control en actie control @Override public JefMenuBar createMenuBar() { JefMenuBar menuBar = new JefMenuBar(); // add file menu JefMenu menu = MenuFactory.create(MenuFactory.Type.FILE); // menu.add(MenuItemFactory.createListControls(false)); menu.add(MenuItemFactory.createListControls(null, true, false, false)); menu.addSeparator(); menu.add(MenuItemFactory.createGridControls(MainPanel.class, orderGrid)); menu.addSeparator(); menu.add(MenuItemFactory.create(MenuItemFactory.Type.CLOSE)); menuBar.add(menu); // add edit menu menu = MenuFactory.create(MenuFactory.Type.EDIT); menu.add(MenuItemFactory.createActionControls(new MenuItemFactory.Type[] { MenuItemFactory.Type.INSERT, MenuItemFactory.Type.UPDATE, MenuItemFactory.Type.DELETE })); menuBar.add(menu); menu.addSeparator(); return menuBar; }","title":"8: Toevoegen Menu"},{"location":"jefViewOnly/#9-search-toevoegen","text":"U lijst programma voorzien met de zoek atributen Constructor van function setInitialFunctionEvent(new FunctionEvent(SEARCH_EVENTCODE)) toevoegen configureFunctionEventAdapters overschrijven + aproviders toevoegen en EventAdaptersFactory toevoegen orderlist in je datalogic set blocked zetten + refresh afzetten + provider toevoegen(EventAdaptersFactory) EXORDHDR11 private static AS400DataSet keyRecord() { return AS400DataSet.builder(KEY_VERSION).with(new WMSCompany(), new Order()).build(); } Function public Function(ApplicationManager applicationManager, GUIFunctionContext parent, Parameter[] parameters) { super(applicationManager, parent, parameters); // search event kan meedere event verwachten setInitialFunctionEvent(new FunctionEvent(SEARCH_EVENTCODE)); } @Override protected void configureFunctionEventAdapters(Collection<eventadapter> adapters) { super.configureFunctionEventAdapters(adapters); Provider orderList = getDataContext().getProvider(LIST_DATATABLENAME); Provider orderParameters = getDataContext().getProvider(PARAMETER_DATATABLENAME); adapters.addAll(EventAdaptersFactory.createList(orderParameters, deriveUIName(SEARCH_PANELNAME), orderList)); } DataLogic // verpligting van zoek ceteria orderList.setBlocked(true); addProvider(new ParameterProvider(this, PARAMETER_DATATABLENAME, orderList)); @Override public void start() throws FunctionException { // Deze is niet nodig omdat we de orderlist blokeren // orderList.refresh(); }","title":"9: Search Toevoegen"},{"location":"jefViewOnly/#10-criteria-panel-toolbar-panel-toevoegen-aan-de-gui","text":"Datalogic ColumnValuesProvider toevoegen voor onze RefreshPicklistFEA ReorderFEA en FilterFEA op de orderlist in onze function zoek adappter toevoegen configureFunctionEventAdapters overschrijven plus de andere addapters zelf toevoegen (driveUIName) main panel addLocalOrderingColumns, addLocalMultiFilteringColumn, addLocalSingleFilteringColumn op onze get table van onze order createria panel toevoegen aan de toolbar DataLogic addProvider(new ColumnValuesProvider(this, CARRIER_FILTER_DATATABLENAME, orderList, Carrier.NAME)); addProvider(new ColumnValuesProvider(this, IS_RUSH_ORDER_FILTER_DATATABLENAME, orderList, IsRushOrder.NAME)); Function // reorder event adapters.add(new ReorderFEA(orderList, null, null)); // event add filter adapters.add(new FilterFEA(orderList, null, null)); // new refresh pickup event // we moeten providers toevoegen in onze data logic adapters.add(new RefreshPicklistFEA()); MainPanel // sorteren op header van grid van je Attribute orderGrid.getTable() .getTableHeader() .addLocalOrderingColumns(new String[] { OrderDate.NAME, DeliveryDate.NAME }); // filteren met Multy Filter orderGrid.getTable() .getTableHeader() .addLocalMultiFilteringColumn(LIST_DATATABLENAME, Carrier.NAME, new PickListDescription(CARRIER_FILTER_DATATABLENAME, Carrier.NAME, Carrier.NAME)); // filteren met Single Filter orderGrid.getTable() .getTableHeader() .addLocalSingleFilteringColumn(LIST_DATATABLENAME, IsRushOrder.NAME, new PickListDescription(IS_RUSH_ORDER_FILTER_DATATABLENAME, IsRushOrder.NAME, IsRushOrder.NAME), true, ASTERISK, NULL); // toolbar toevoegen met criteria toevoegen add(JefToolBar.joinToolBarWithCriteria(createOrderListToolBar(), createCriteriaPanel()), NORTH); private static CriteriaPanel createCriteriaPanel() { CriteriaPanel panel = new CriteriaPanel(); // zoeken altijd via zoekscherm // Jefmigbuilder voor zowel zoeken als label tonen op je DATATABELNAAM JefMigBuilder builder = new JefMigBuilder(MigLayoutFactory.create(MigLayoutFactory.Type.WITHOUT_INSETS), PARAMETER_DATATABLENAME, panel); builder.appendLabelAndComponent(DataComponentFactory.Type.JEFLABEL, Order.NAME); return panel; }","title":"10 : Criteria panel / toolbar / panel toevoegen aan de GUI"},{"location":"markdown-cheat-sheet/","text":"Markdown Cheat Sheet Thanks for visiting The Markdown Guide ! This Markdown cheat sheet provides a quick overview of all the Markdown syntax elements. It can\u2019t cover every edge case, so if you need more information about any of these elements, refer to the reference guides for basic syntax and extended syntax . Basic Syntax These are the elements outlined in John Gruber\u2019s original design document. All Markdown applications support these elements. Heading H1 H2 H3 Bold bold text Italic italicized text Blockquote blockquote Ordered List First item Second item Third item Unordered List First item Second item Third item Code code Horizontal Rule Link title Image Extended Syntax These elements extend the basic syntax by adding additional features. Not all Markdown applications support these elements. Table Syntax Description Header Title Paragraph Text Fenced Code Block { \"firstName\": \"John\", \"lastName\": \"Smith\", \"age\": 25 } Footnote Here's a sentence with a footnote. [^1] [^1]: This is the footnote. Heading ID My Great Heading {#custom-id} Definition List term : definition Strikethrough ~~The world is flat.~~ Task List [x] Write the press release [ ] Update the website [ ] Contact the media","title":"Markdown Cheat Sheet"},{"location":"markdown-cheat-sheet/#markdown-cheat-sheet","text":"Thanks for visiting The Markdown Guide ! This Markdown cheat sheet provides a quick overview of all the Markdown syntax elements. It can\u2019t cover every edge case, so if you need more information about any of these elements, refer to the reference guides for basic syntax and extended syntax .","title":"Markdown Cheat Sheet"},{"location":"markdown-cheat-sheet/#basic-syntax","text":"These are the elements outlined in John Gruber\u2019s original design document. All Markdown applications support these elements.","title":"Basic Syntax"},{"location":"markdown-cheat-sheet/#heading","text":"","title":"Heading"},{"location":"markdown-cheat-sheet/#h1","text":"","title":"H1"},{"location":"markdown-cheat-sheet/#h2","text":"","title":"H2"},{"location":"markdown-cheat-sheet/#h3","text":"","title":"H3"},{"location":"markdown-cheat-sheet/#bold","text":"bold text","title":"Bold"},{"location":"markdown-cheat-sheet/#italic","text":"italicized text","title":"Italic"},{"location":"markdown-cheat-sheet/#blockquote","text":"blockquote","title":"Blockquote"},{"location":"markdown-cheat-sheet/#ordered-list","text":"First item Second item Third item","title":"Ordered List"},{"location":"markdown-cheat-sheet/#unordered-list","text":"First item Second item Third item","title":"Unordered List"},{"location":"markdown-cheat-sheet/#code","text":"code","title":"Code"},{"location":"markdown-cheat-sheet/#horizontal-rule","text":"","title":"Horizontal Rule"},{"location":"markdown-cheat-sheet/#link","text":"title","title":"Link"},{"location":"markdown-cheat-sheet/#image","text":"","title":"Image"},{"location":"markdown-cheat-sheet/#extended-syntax","text":"These elements extend the basic syntax by adding additional features. Not all Markdown applications support these elements.","title":"Extended Syntax"},{"location":"markdown-cheat-sheet/#table","text":"Syntax Description Header Title Paragraph Text","title":"Table"},{"location":"markdown-cheat-sheet/#fenced-code-block","text":"{ \"firstName\": \"John\", \"lastName\": \"Smith\", \"age\": 25 }","title":"Fenced Code Block"},{"location":"markdown-cheat-sheet/#footnote","text":"Here's a sentence with a footnote. [^1] [^1]: This is the footnote.","title":"Footnote"},{"location":"markdown-cheat-sheet/#heading-id","text":"","title":"Heading ID"},{"location":"markdown-cheat-sheet/#my-great-heading-custom-id","text":"","title":"My Great Heading {#custom-id}"},{"location":"markdown-cheat-sheet/#definition-list","text":"term : definition","title":"Definition List"},{"location":"markdown-cheat-sheet/#strikethrough","text":"~~The world is flat.~~","title":"Strikethrough"},{"location":"markdown-cheat-sheet/#task-list","text":"[x] Write the press release [ ] Update the website [ ] Contact the media","title":"Task List"},{"location":"rpg/","text":"RPG informatie .PF # Physical file data (kolom omschrijvingen) .Lf # Logic file view benaderen (keys) (bepaalt sortering data die opgehaald wordt ((her)indexering) (uniek benaderen of niet via UNIQUE) Commands peek - View edit voor je logic of physical files (Aleen in develop omgeving). Strsql - Sql in AS400. start sql SELECT * FROM TWSMAJDTA/EXORDHDR upddta - Nog een manier om je data te zien wrkjob - Active Job Log benaderen (F10 Voor job info, F1 detail, F14 job log) (Shift + F). wa - Alle jobs Werk Omgeving TWS MAJ DTA / EXORHDR max (10 chars)` TWS - Transport Warehousing MAJ - Major DTA - Logic physic data EX ample OR der H ea D e R MIN - Minor DANLAD - Persoonlijke Omgeving EMG - Emergency TS1 - Test / Service Programma's File Naam Info EXORDHDRR1 - Filename + R + Index Resolver Update , Delete , Insert , New , Get - Nodig Voor Update programma EXORDHDRL1 - Filename + P + Logical Provider Lijst programma's roepen providers aan voor data door te sturen naar de data formatter. Ascending Descending Next Back First Last Fetch Detail Validate EXORDHDRD1 - Filename + D + Index Data Formatter Data resetten, opvullen, nakijken en record terugsturen of niet EXORDHDRU1 - Filename + U + Logical File Access Een feld opvragen uit een file uit een record die je verder niet nodig hebt - Count - Record checken (setll) EXORDHDRG1 - Filename + G + Logical Get Read Meer dan een veld uit een file die je verder niet nodig hebt - Eerste of laatste record ophalen EXORDHDRS1 + Filename + S + Index Service Program Als je twee databases nodig hebt waar voor bijkomende logica om lijsten niet onodig te openen in andere service programma's - Duplicate code EXMORDS001 + GroepName + S + 3 cijfers 001 Converter Als men in een tweede tabel wilt zoeken en record uit de eerste tabel wilt tonen Programma's File Naam Info EXORDHDR11 - Filename + 1 + Index Lijst Update , Delete , Insert , New , Get - Nodig Voor Update programma EXORDHDR01 - Filename + 0 + Index Update Lijst programma's roepen providers aan voor data door te sturen naar de data formatter. EXORDHDR21 - Filename + 2 + Index Resync Data resetten, opvullen, nakijken en record terugsturen of niet XML Genereerd op je Physical file Group Entity Hoofd Indeling / Domain Subdomain Records - Concept van je data structuur Attribute - Naamgeving(Pascal Casing) / Logishe Naamgeving Bij sommige attributen moet je een betere naamgeving geven FLAGHRUSH -> IsRushOrder. Naam moet niet altijd dezelfde zijn-> Niveau van database (Java attribute staat op een hoger niveau) Usage - Type(Conversie) dat verwacht word aan de andere kant (Data is packed Decimal)(logging) Type Info A AlphaNumeric -> String P Packed Decimal-> Double D Date T Time Logicals Blok Service programma gebaseerd op je Logic File voor ieder block KeyList (Keys) Providers Voor het benaderen van de data Resolver Voor Crud acties Programma Gebaseerd op je Logical(s) File(s) Lijst Update Rysync Omschrijving Activeren Only_new Deactiveren Skip <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?> <qtlsjxml group=\"Example\" entity=\"OrderHeader\" version=\"1.1.0\"> <filetree> <mainfile id=\"1\" name=\"EXORDHDR\" rec=\"EXORDHDRR\"> <fieldlist> <field name=\"COMPANY\" attribute=\"Company\" type=\"A\" len=\"2\" label=\"Company\"/> <field name=\"ORDER\" attribute=\"Order\" type=\"A\" len=\"12\" label=\"Order\"/> <field name=\"ORDERDATE\" attribute=\"OrderDate\" type=\"P\" len=\"8\" dec=\"0\" usage=\"*DATE\" label=\"Order Date\"/> <field name=\"DELIVDATE\" attribute=\"DeliveryDate\" type=\"P\" len=\"8\" dec=\"0\" usage=\"*DATE\" label=\"Delivery date\"/> <field name=\"CARRIER\" attribute=\"Carrier\" type=\"A\" len=\"30\" label=\"Carrier\"/> <field name=\"STATUS\" attribute=\"Status\" type=\"A\" len=\"2\" label=\"Status\"/> <field name=\"FLAGRUSH\" attribute=\"IsRushOrder\" type=\"A\" len=\"1\" usage=\"*IND\" label=\"Rush Order\"/> <field name=\"CRTPGNM\" attribute=\"ProgramCreated\" type=\"A\" len=\"10\" usage=\"*LOG\" label=\"Creation program\"/> <field name=\"CRTUSER\" attribute=\"UserCreated\" type=\"A\" len=\"10\" usage=\"*LOG\" label=\"Creation user\"/> <field name=\"CRTDATE\" attribute=\"DateCreated\" type=\"P\" len=\"8\" dec=\"0\" usage=\"*LOG,*DATE\" label=\"Creation date\"/> <field name=\"CRTTIME\" attribute=\"TimeCreated\" type=\"P\" len=\"6\" dec=\"0\" usage=\"*LOG,*TIME\" label=\"Creation time\"/> <field name=\"CHGPGNM\" attribute=\"ProgramChanged\" type=\"A\" len=\"10\" usage=\"*LOG\" label=\"Change program\"/> <field name=\"CHGUSER\" attribute=\"UserChanged\" type=\"A\" len=\"10\" usage=\"*LOG\" label=\"Change user\"/> <field name=\"CHGDATE\" attribute=\"DateChanged\" type=\"P\" len=\"8\" dec=\"0\" usage=\"*LOG,*DATE\" label=\"Change date\"/> <field name=\"CHGTIME\" attribute=\"TimeChanged\" type=\"P\" len=\"6\" dec=\"0\" usage=\"*LOG,*TIME\" label=\"Change time\"/> <field name=\"JOBNAM\" attribute=\"JobName\" type=\"A\" len=\"10\" usage=\"*LOG\" label=\"Job name last event (CRT or CHG)\"/> <field name=\"JOBUSR\" attribute=\"JobUser\" type=\"A\" len=\"10\" usage=\"*LOG\" label=\"Job user last event (CRT or CHG)\"/> <field name=\"JOBNBR\" attribute=\"JobNumber\" type=\"P\" len=\"6\" dec=\"0\" usage=\"*LOG\" label=\"Job number last event (CRT or CHG)\"/> <field name=\"CALLER1\" attribute=\"Caller1\" type=\"A\" len=\"10\" usage=\"*LOG\" label=\"Caller of CRTPGNM (if CRT) or CHGPGNM (if CHG)\"/> <field name=\"CALLER2\" attribute=\"Caller2\" type=\"A\" len=\"10\" usage=\"*LOG\" label=\"Caller of CALLER1\"/> </fieldlist> <formatter source=\"EXORDHDRD1\" go=\"only_new\"> <text>Filter and format procedures for EXORDHDR</text> </formatter> <formatter source=\"EXORDHDRC1\" go=\"only_new\"> <text>Convert from EXORDDTL TO EXORDHDR</text> </formatter> <index name=\"EXORDHDRL1\"> <text>COMPANY/ORDER - UNIQUE</text> <keylist> <key name=\"COMPANY\"/> <key name=\"ORDER\"/> </keylist> <fileAccess source=\"EXORDHDRU1\" go=\"only_new\"/> <getRead source=\"EXORDHDRG1\" go=\"only_new\"/> <provider source=\"EXORDHDRP1\" go=\"only_new\"/> <resolver source=\"EXORDHDRR1\" go=\"only_new\"> <text>Actions ...</text> </resolver> </index> <text>Example Order Header</text> </mainfile> </filetree> <programs> <program source=\"EXORDHDR01\" type=\"UPDATE\" go=\"only_new\"> <based_on> <index name=\"EXORDHDRL1\"/> </based_on> <text>Example order header action</text> </program> <program source=\"EXORDHDR11\" type=\"LIST\" go=\"only_new\"> <based_on> <index name=\"EXORDHDRL1\"/> <index name=\"EXORDHDRL2\"/> <index name=\"EXORDHDRL3\"/> </based_on> <text>Example order header list danlad</text> </program> ... Lijst *1 Flow Keys controleren -> context inializeren (eerste call (refresh java)) -> call naar Formater (lange) -> bind juiste formatter in context -> buffer inializeren (iedere call) -> provider benaderen met de call + context meegeven <- RC code terug sturen TODO Keys Controleren Data Structure Declaraties Declaraties Info Keys meegegeven keys Keychoice constanten voor bepalen van juiste provider(logic Context context voor je provider die gestuurd wordt en terug komt- Init_Context -> eerste call (11) -> rc ok (100) Data Formatter Example_OrderHeader_EXORDHDRD1_D002 -> binden van de juiste formater Buffer Context_Init_Buffer -> bij iedere call (100) inPSSR sub routine voor je programma errors (exsr, begsr) Init_LastMessageSpace laatste gelogde foutmelding keysPointer %addr(keys) Adressering van je keys(variable) in je keypointer recordPointer %addr(Data) Adressering van je data(variable) in je recordPointer Vergelijkingen Vergelijkingen Info KeySize Controleren keysize KeyVersion Controleren key version OpCode Operation codes Calls Calls Info exsr callResolver (Invoke Subroutine) call naar begsb begsr callResolver (Beginning of Subroutine) begin definitie van je subroutine KeyChoice Voor juister provider Calls Provider Calls Provider Info Ascending Pointer zetten + next Descending Pointer setten + back Next (load factor)vanaf context keys positioneren next (10 ok ) Back (load factor)vanaf context keys positioneren back (10 ok ) First positioneren en terug gaan lezen load factor (begin keys zitten in de context) Last positioneren van achter en terug gaan lezen naar voor load factor (begin keys zitten in de context) Fetch 1 ophalen of error Detail 1 ophalen of leeg Validate 1 ophalen of melding van meer of error Keys Keys Info Frozen keys welke exacte keys ge nodig hebt Summer keys eerste record van de groepering Update 0* TODO Keys Controleren Data Set Prototype Declaraties Declaraties Info Keys meegegeven keys Record van je resolver record (pointer) Buffer Context_Init_Buffer -> bij iedere call (100) inPSSR sub routine voor je programma errors (exsr, begsr) Init_LastMessageSpace laatste gelogde foutmelding keysPointer %addr(keys) Adressering van je keys(variable) in je keypointer recordPointer %addr(Data) Adressering van je data(variable) in je recordPointer Vergelijkingen Vergelijkingen Info KeySize Controleren keysize KeyVersion Controleren key version DataVersion Controleren Data version met je resolver record (input met data object) OpCode Operation codes Calls Calls Info exsr callResolver (Invoke Subroutine) call naar begsb begsr callResolver (Beginning of Subroutine) begin definitie van je subroutine Calls Provider Calls Provider Info new nieuwe default object (prototype) insert toevoegen get ophalen update updaten delete wissen Resync 2* Flow keys controleren -> context inializeren (eenmalig per call geen ok check op 11 lijst)) -> call naar Formater (lange) -> bind juiste formatter in context -> buffer inializeren (iedere call) -> provider benaderen met de call fetch + context meegeven <- RC code terug sturen TODO Keys Controleren Data Structure Declaraties Declaraties Info Keys meegegeven keys Keychoice constanten voor bepalen van juiste provider(logic Context context voor je provider die gestuurd wordt en terug komt- Init_Context -> eerste call (11) -> rc ok (100) Data Formatter Example_OrderHeader_EXORDHDRD1_D002 -> binden van de juiste formater Buffer Context_Init_Buffer -> bij iedere call (100) inPSSR sub routine voor je programma errors (exsr, begsr) Init_LastMessageSpace laatste gelogde foutmelding keysPointer %addr(keys) Adressering van je keys(variable) in je keypointer recordPointer %addr(Data) Adressering van je data(variable) in je recordPointer Vergelijkingen Vergelijkingen Info KeySize Controleren keysize KeyVersion Controleren key version OpCode Operation codes Calls Calls Info exsr callResolver (Invoke Subroutine) call naar begsb begsr callResolver (Beginning of Subroutine) begin definitie van je subroutine KeyChoice Voor juister provider Calls Provider Calls Provider Info Fetch 1 ophalen of error Dataformater D001 Model voor volgende data Data formatters D002 Records nakijken data reset opvullen met defailt waarde; mappen en controleren eventueel extra controlen voor bepaalde records door te laten meerder of geen records sturen Provider Provider programmeren we niet in . Omdat deze ieder moment gegenereerd kan worden. En als we provider programmeren kunnen we die alleen voor \u00e9\u00e9n programma gebruiken. Calls Provider Info Ascending Pointer zetten + next Descending Pointer setten + back Next (load factor)vanaf context keys positioneren next (10 ok ) Back (load factor)vanaf context keys positioneren back (10 ok ) First positioneren en terug gaan lezen load factor (begin keys zitten in de context) Last positioneren van achter en terug gaan lezen naar voor load factor (begin keys zitten in de context) Fetch 1 ophalen of error Detail 1 ophalen of leeg Validate 1 ophalen of melding van meer of error ProtoType Info dcl-pr Declaraties prototype met (return codes) records input records Export van de calls Resolver Crud Operaties TODO Copy member nakijken Bepalen van keys en of je u record meegeeft in je calls Crud Info new nieuwe default object (prototype) insert toevoegen get welke velden ken je al en moet je niet meer ophalen update updaten delete wissen ProtoType Info dcl-ds Declaratie data structure dcl-pr Declaraties prototype met (return codes) records input records Export van de calls Delete procedure interface Find and lock record (chain) -> ophalen van je data Record comparing buffer Set pointer Delete record + unlock (error) return RC_ok; Get procedure interface Find record Save record for comparison in buffer Fill record + (mappen) return RC_ok; Insert procedure interface Check Duplicate record Fill record + (mappen) Add record return RC_ok; Update procedure interface Find and lock record (chain) -> ophalen van je data Fill record + (mappen) Overwrite record content + unlock (error) return RC_ok; New procedure interface Clear data opvullen met default values return RC_ok; Lock's GEEN LOCKS usage -> input output of geen read(n) -> lezen chain(n) -> zoeken LOCKS usage -> update delete chain read delete update","title":"Informatie"},{"location":"rpg/#rpg-informatie","text":".PF # Physical file data (kolom omschrijvingen) .Lf # Logic file view benaderen (keys) (bepaalt sortering data die opgehaald wordt ((her)indexering) (uniek benaderen of niet via UNIQUE)","title":"RPG informatie"},{"location":"rpg/#commands","text":"peek - View edit voor je logic of physical files (Aleen in develop omgeving). Strsql - Sql in AS400. start sql SELECT * FROM TWSMAJDTA/EXORDHDR upddta - Nog een manier om je data te zien wrkjob - Active Job Log benaderen (F10 Voor job info, F1 detail, F14 job log) (Shift + F). wa - Alle jobs","title":"Commands"},{"location":"rpg/#werk-omgeving","text":"TWS MAJ DTA / EXORHDR max (10 chars)` TWS - Transport Warehousing MAJ - Major DTA - Logic physic data EX ample OR der H ea D e R MIN - Minor DANLAD - Persoonlijke Omgeving EMG - Emergency TS1 - Test /","title":"Werk Omgeving"},{"location":"rpg/#service-programmas","text":"File Naam Info EXORDHDRR1 - Filename + R + Index Resolver Update , Delete , Insert , New , Get - Nodig Voor Update programma EXORDHDRL1 - Filename + P + Logical Provider Lijst programma's roepen providers aan voor data door te sturen naar de data formatter. Ascending Descending Next Back First Last Fetch Detail Validate EXORDHDRD1 - Filename + D + Index Data Formatter Data resetten, opvullen, nakijken en record terugsturen of niet EXORDHDRU1 - Filename + U + Logical File Access Een feld opvragen uit een file uit een record die je verder niet nodig hebt - Count - Record checken (setll) EXORDHDRG1 - Filename + G + Logical Get Read Meer dan een veld uit een file die je verder niet nodig hebt - Eerste of laatste record ophalen EXORDHDRS1 + Filename + S + Index Service Program Als je twee databases nodig hebt waar voor bijkomende logica om lijsten niet onodig te openen in andere service programma's - Duplicate code EXMORDS001 + GroepName + S + 3 cijfers 001 Converter Als men in een tweede tabel wilt zoeken en record uit de eerste tabel wilt tonen","title":"Service Programma's"},{"location":"rpg/#programmas","text":"File Naam Info EXORDHDR11 - Filename + 1 + Index Lijst Update , Delete , Insert , New , Get - Nodig Voor Update programma EXORDHDR01 - Filename + 0 + Index Update Lijst programma's roepen providers aan voor data door te sturen naar de data formatter. EXORDHDR21 - Filename + 2 + Index Resync Data resetten, opvullen, nakijken en record terugsturen of niet","title":"Programma's"},{"location":"rpg/#xml","text":"Genereerd op je Physical file Group Entity Hoofd Indeling / Domain Subdomain Records - Concept van je data structuur Attribute - Naamgeving(Pascal Casing) / Logishe Naamgeving Bij sommige attributen moet je een betere naamgeving geven FLAGHRUSH -> IsRushOrder. Naam moet niet altijd dezelfde zijn-> Niveau van database (Java attribute staat op een hoger niveau) Usage - Type(Conversie) dat verwacht word aan de andere kant (Data is packed Decimal)(logging) Type Info A AlphaNumeric -> String P Packed Decimal-> Double D Date T Time Logicals Blok Service programma gebaseerd op je Logic File voor ieder block KeyList (Keys) Providers Voor het benaderen van de data Resolver Voor Crud acties Programma Gebaseerd op je Logical(s) File(s) Lijst Update Rysync Omschrijving Activeren Only_new Deactiveren Skip <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?> <qtlsjxml group=\"Example\" entity=\"OrderHeader\" version=\"1.1.0\"> <filetree> <mainfile id=\"1\" name=\"EXORDHDR\" rec=\"EXORDHDRR\"> <fieldlist> <field name=\"COMPANY\" attribute=\"Company\" type=\"A\" len=\"2\" label=\"Company\"/> <field name=\"ORDER\" attribute=\"Order\" type=\"A\" len=\"12\" label=\"Order\"/> <field name=\"ORDERDATE\" attribute=\"OrderDate\" type=\"P\" len=\"8\" dec=\"0\" usage=\"*DATE\" label=\"Order Date\"/> <field name=\"DELIVDATE\" attribute=\"DeliveryDate\" type=\"P\" len=\"8\" dec=\"0\" usage=\"*DATE\" label=\"Delivery date\"/> <field name=\"CARRIER\" attribute=\"Carrier\" type=\"A\" len=\"30\" label=\"Carrier\"/> <field name=\"STATUS\" attribute=\"Status\" type=\"A\" len=\"2\" label=\"Status\"/> <field name=\"FLAGRUSH\" attribute=\"IsRushOrder\" type=\"A\" len=\"1\" usage=\"*IND\" label=\"Rush Order\"/> <field name=\"CRTPGNM\" attribute=\"ProgramCreated\" type=\"A\" len=\"10\" usage=\"*LOG\" label=\"Creation program\"/> <field name=\"CRTUSER\" attribute=\"UserCreated\" type=\"A\" len=\"10\" usage=\"*LOG\" label=\"Creation user\"/> <field name=\"CRTDATE\" attribute=\"DateCreated\" type=\"P\" len=\"8\" dec=\"0\" usage=\"*LOG,*DATE\" label=\"Creation date\"/> <field name=\"CRTTIME\" attribute=\"TimeCreated\" type=\"P\" len=\"6\" dec=\"0\" usage=\"*LOG,*TIME\" label=\"Creation time\"/> <field name=\"CHGPGNM\" attribute=\"ProgramChanged\" type=\"A\" len=\"10\" usage=\"*LOG\" label=\"Change program\"/> <field name=\"CHGUSER\" attribute=\"UserChanged\" type=\"A\" len=\"10\" usage=\"*LOG\" label=\"Change user\"/> <field name=\"CHGDATE\" attribute=\"DateChanged\" type=\"P\" len=\"8\" dec=\"0\" usage=\"*LOG,*DATE\" label=\"Change date\"/> <field name=\"CHGTIME\" attribute=\"TimeChanged\" type=\"P\" len=\"6\" dec=\"0\" usage=\"*LOG,*TIME\" label=\"Change time\"/> <field name=\"JOBNAM\" attribute=\"JobName\" type=\"A\" len=\"10\" usage=\"*LOG\" label=\"Job name last event (CRT or CHG)\"/> <field name=\"JOBUSR\" attribute=\"JobUser\" type=\"A\" len=\"10\" usage=\"*LOG\" label=\"Job user last event (CRT or CHG)\"/> <field name=\"JOBNBR\" attribute=\"JobNumber\" type=\"P\" len=\"6\" dec=\"0\" usage=\"*LOG\" label=\"Job number last event (CRT or CHG)\"/> <field name=\"CALLER1\" attribute=\"Caller1\" type=\"A\" len=\"10\" usage=\"*LOG\" label=\"Caller of CRTPGNM (if CRT) or CHGPGNM (if CHG)\"/> <field name=\"CALLER2\" attribute=\"Caller2\" type=\"A\" len=\"10\" usage=\"*LOG\" label=\"Caller of CALLER1\"/> </fieldlist> <formatter source=\"EXORDHDRD1\" go=\"only_new\"> <text>Filter and format procedures for EXORDHDR</text> </formatter> <formatter source=\"EXORDHDRC1\" go=\"only_new\"> <text>Convert from EXORDDTL TO EXORDHDR</text> </formatter> <index name=\"EXORDHDRL1\"> <text>COMPANY/ORDER - UNIQUE</text> <keylist> <key name=\"COMPANY\"/> <key name=\"ORDER\"/> </keylist> <fileAccess source=\"EXORDHDRU1\" go=\"only_new\"/> <getRead source=\"EXORDHDRG1\" go=\"only_new\"/> <provider source=\"EXORDHDRP1\" go=\"only_new\"/> <resolver source=\"EXORDHDRR1\" go=\"only_new\"> <text>Actions ...</text> </resolver> </index> <text>Example Order Header</text> </mainfile> </filetree> <programs> <program source=\"EXORDHDR01\" type=\"UPDATE\" go=\"only_new\"> <based_on> <index name=\"EXORDHDRL1\"/> </based_on> <text>Example order header action</text> </program> <program source=\"EXORDHDR11\" type=\"LIST\" go=\"only_new\"> <based_on> <index name=\"EXORDHDRL1\"/> <index name=\"EXORDHDRL2\"/> <index name=\"EXORDHDRL3\"/> </based_on> <text>Example order header list danlad</text> </program> ...","title":"XML"},{"location":"rpg/#lijst","text":"*1 Flow Keys controleren -> context inializeren (eerste call (refresh java)) -> call naar Formater (lange) -> bind juiste formatter in context -> buffer inializeren (iedere call) -> provider benaderen met de call + context meegeven <- RC code terug sturen TODO Keys Controleren Data Structure Declaraties Declaraties Info Keys meegegeven keys Keychoice constanten voor bepalen van juiste provider(logic Context context voor je provider die gestuurd wordt en terug komt- Init_Context -> eerste call (11) -> rc ok (100) Data Formatter Example_OrderHeader_EXORDHDRD1_D002 -> binden van de juiste formater Buffer Context_Init_Buffer -> bij iedere call (100) inPSSR sub routine voor je programma errors (exsr, begsr) Init_LastMessageSpace laatste gelogde foutmelding keysPointer %addr(keys) Adressering van je keys(variable) in je keypointer recordPointer %addr(Data) Adressering van je data(variable) in je recordPointer Vergelijkingen Vergelijkingen Info KeySize Controleren keysize KeyVersion Controleren key version OpCode Operation codes Calls Calls Info exsr callResolver (Invoke Subroutine) call naar begsb begsr callResolver (Beginning of Subroutine) begin definitie van je subroutine KeyChoice Voor juister provider Calls Provider Calls Provider Info Ascending Pointer zetten + next Descending Pointer setten + back Next (load factor)vanaf context keys positioneren next (10 ok ) Back (load factor)vanaf context keys positioneren back (10 ok ) First positioneren en terug gaan lezen load factor (begin keys zitten in de context) Last positioneren van achter en terug gaan lezen naar voor load factor (begin keys zitten in de context) Fetch 1 ophalen of error Detail 1 ophalen of leeg Validate 1 ophalen of melding van meer of error Keys Keys Info Frozen keys welke exacte keys ge nodig hebt Summer keys eerste record van de groepering","title":"Lijst"},{"location":"rpg/#update","text":"0* TODO Keys Controleren Data Set Prototype Declaraties Declaraties Info Keys meegegeven keys Record van je resolver record (pointer) Buffer Context_Init_Buffer -> bij iedere call (100) inPSSR sub routine voor je programma errors (exsr, begsr) Init_LastMessageSpace laatste gelogde foutmelding keysPointer %addr(keys) Adressering van je keys(variable) in je keypointer recordPointer %addr(Data) Adressering van je data(variable) in je recordPointer Vergelijkingen Vergelijkingen Info KeySize Controleren keysize KeyVersion Controleren key version DataVersion Controleren Data version met je resolver record (input met data object) OpCode Operation codes Calls Calls Info exsr callResolver (Invoke Subroutine) call naar begsb begsr callResolver (Beginning of Subroutine) begin definitie van je subroutine Calls Provider Calls Provider Info new nieuwe default object (prototype) insert toevoegen get ophalen update updaten delete wissen","title":"Update"},{"location":"rpg/#resync","text":"2* Flow keys controleren -> context inializeren (eenmalig per call geen ok check op 11 lijst)) -> call naar Formater (lange) -> bind juiste formatter in context -> buffer inializeren (iedere call) -> provider benaderen met de call fetch + context meegeven <- RC code terug sturen TODO Keys Controleren Data Structure Declaraties Declaraties Info Keys meegegeven keys Keychoice constanten voor bepalen van juiste provider(logic Context context voor je provider die gestuurd wordt en terug komt- Init_Context -> eerste call (11) -> rc ok (100) Data Formatter Example_OrderHeader_EXORDHDRD1_D002 -> binden van de juiste formater Buffer Context_Init_Buffer -> bij iedere call (100) inPSSR sub routine voor je programma errors (exsr, begsr) Init_LastMessageSpace laatste gelogde foutmelding keysPointer %addr(keys) Adressering van je keys(variable) in je keypointer recordPointer %addr(Data) Adressering van je data(variable) in je recordPointer Vergelijkingen Vergelijkingen Info KeySize Controleren keysize KeyVersion Controleren key version OpCode Operation codes Calls Calls Info exsr callResolver (Invoke Subroutine) call naar begsb begsr callResolver (Beginning of Subroutine) begin definitie van je subroutine KeyChoice Voor juister provider Calls Provider Calls Provider Info Fetch 1 ophalen of error","title":"Resync"},{"location":"rpg/#dataformater","text":"D001 Model voor volgende data Data formatters D002 Records nakijken data reset opvullen met defailt waarde; mappen en controleren eventueel extra controlen voor bepaalde records door te laten meerder of geen records sturen","title":"Dataformater"},{"location":"rpg/#provider","text":"Provider programmeren we niet in . Omdat deze ieder moment gegenereerd kan worden. En als we provider programmeren kunnen we die alleen voor \u00e9\u00e9n programma gebruiken. Calls Provider Info Ascending Pointer zetten + next Descending Pointer setten + back Next (load factor)vanaf context keys positioneren next (10 ok ) Back (load factor)vanaf context keys positioneren back (10 ok ) First positioneren en terug gaan lezen load factor (begin keys zitten in de context) Last positioneren van achter en terug gaan lezen naar voor load factor (begin keys zitten in de context) Fetch 1 ophalen of error Detail 1 ophalen of leeg Validate 1 ophalen of melding van meer of error ProtoType Info dcl-pr Declaraties prototype met (return codes) records input records Export van de calls","title":"Provider"},{"location":"rpg/#resolver","text":"Crud Operaties TODO Copy member nakijken Bepalen van keys en of je u record meegeeft in je calls Crud Info new nieuwe default object (prototype) insert toevoegen get welke velden ken je al en moet je niet meer ophalen update updaten delete wissen ProtoType Info dcl-ds Declaratie data structure dcl-pr Declaraties prototype met (return codes) records input records Export van de calls Delete procedure interface Find and lock record (chain) -> ophalen van je data Record comparing buffer Set pointer Delete record + unlock (error) return RC_ok; Get procedure interface Find record Save record for comparison in buffer Fill record + (mappen) return RC_ok; Insert procedure interface Check Duplicate record Fill record + (mappen) Add record return RC_ok; Update procedure interface Find and lock record (chain) -> ophalen van je data Fill record + (mappen) Overwrite record content + unlock (error) return RC_ok; New procedure interface Clear data opvullen met default values return RC_ok;","title":"Resolver"},{"location":"rpg/#locks","text":"GEEN LOCKS usage -> input output of geen read(n) -> lezen chain(n) -> zoeken LOCKS usage -> update delete chain read delete update","title":"Lock's"},{"location":"rpgExample/","text":"RPG Voorbeelden DataTypes DCL-C Define a named constant DCL-DS Define a data structure END-DS End a data structure {DCL-PARM} Define a parameter DCL-PI Define a procedure interface (dcl-proc end-proc) END-PI End a procedure interface DCL-PR Define a prototype END-PR End a prototype DCL-S Define a standalone field {DCL-SUBF} Define a subfield Declaraties BINDEC(digits {: decimal-positions}) CHAR(length) DATE{(format{separator})} FLOAT(bytes) GRAPH(length) IND indicator(*on, *off) INT(digits) OBJECT{(*JAVA:class-name)} PACKED(digits {: decimal-positions}) gebruik dit boven digits , ditgits aleen als tijdelijke variabele (counter ...) POINTER{(*PROC)} TIME{(format{separator})} TIMESTAMP{(fractional-seconds)} UCS2(length) UNS(digits) VARCHAR(length {:2 | 4}) VARGRAPH(length {:2 | 4}) VARUCS2(length {:2 | 4}) ZONED(digits {: decimal-positions}) DataFormatter oproepen met extra variable // Choose (and init) \"Data Formatter\" procedure to be used if (KeysDS.KeyChoice = SEARCH_BY_ORDERDATE); RC = Example_OrderHeader_EXORDHDRD1_D002 ( context : DataVersion : DataSize/Count : KeysDS.OrderDateTo ); else; RC = Example_OrderHeader_EXORDHDRD1_D002 ( context : DataVersion : DataSize/Count ); endif; if ( RC <> RC_ok ); return; endif; endif; dcl-ds Format002 qualified based(formatPointer); OrderDateTo packed(8); end-ds; parameter uit Lange call in datastructuur steken // Store the requested settings in the \"FormatData\" part of the \"context\" if ( %parms = %parmnum(i_OrderDateTo) ); Format002.OrderDateTo = CXDateTime_Date_To_Num(i_OrderDateTo); else; Format002.OrderDateTo = *hival; endif; // Check Date if ( EXORDHDRRec.ORDERDATE > Format002.OrderDateTo ); return RC_eof; endif; Zoeken beginnen met RC = Example_OrderHeader_EXORDHDRP1_Ascending ( context : Count : 2 // frozen keys : 0 // summary keys : KeysDS.Company : %trim(KeysDS.Order) + x'FF' ); endif; Zoeken op Dates RC = Example_OrderHeader_EXORDHDRP3_Ascending ( context : Count : 1 // frozen keys : 0 // summary keys : KeysDS.Company : CXDateTime_Date_To_Num(KeysDS.OrderDate) ); Meerdere zoektermen Keychoice dcl-ds KeysDS qualified based(keysPointer); KeyChoice packed(3); Company char(2); Order char(12); Carrier char(30); OrderDate date; OrderDateTo date; end-ds; select; when ( KeysDS.KeyChoice = SEARCH_BY_ORDER ); exsr callEXORDHDRP1; when ( KeysDS.KeyChoice = SEARCH_BY_CONTENT ); exsr callEXORDHDRP2; when ( KeysDS.KeyChoice = SEARCH_BY_ORDERDATE ); exsr callEXORDHDRP3; endsl; Converter C1 Als je uit een record date moet halen voor een andere fetch uit te voeren op een andere database dcl-ds Format001 qualified based(formatPointer); i_ContextRELATIE like(tCX); end-ds; dcl-proc example_relation_EXRELATC1_convertEXORDREL export; dcl-pi *n like(tRC); io_Context like(tCX); i_ContextRELATIE const like(tCX); end-pi; // -- Procedure logic -- // Init formatter within the \"context\" of the caller if ( Init_Context_Format( io_Context : 0 : 0 : %size(Format001) : %paddr(convertEXORDREL) ) <> RC_ok ); // The \"DataFormat\" selection failed. Refer to the job log for more details. return SendMsg('CXE0029'); endif; // Activate \"context\" settings FormatPointer = Get_Context_FormatData( io_Context ); // Store the requested settings in the \"FormatData\" part of the \"context\" Format001.i_ContextRELATIE = i_ContextRELATIE; // Done return RC_ok; end-proc; // -- Internal procedures -- // This is the EXORDRELRC formatter dcl-proc convertEXORDREL; dcl-pi *n like(tRC); io_Context like(tCX); EXORDRELRec const likeds(tEXORDRELRec) options(*nopass); i_RemainingCount uns(5) const options(*nopass); o_Count uns(5) options(*nopass); end-pi; // -- The result set to be returned -- dcl-c MAX_COUNT const(1); // -- Workfields -- dcl-s returnCode like(tRC); // -- Procedure logic -- // Validate incoming context if ( Get_Context_FormatProc(io_Context) <> %paddr(convertEXORDREL) ); // The given \"context\" does not belong to the called procedure // Please contact the IT department. return SendMsg('CXE0010'); endif; // Init \"context\" for caller if ( %parms = %parmnum(io_Context) ); Set_Context_FormatDataID( io_Context : 0 : 0 ); return RC_none; endif; // Check remaining count if ( %parms = %parmnum(o_Count) and i_RemainingCount < MAX_COUNT ); o_Count = 0; return RC_more; endif; // Activate \"context\" settings formatPointer = Get_Context_FormatData( io_Context ); // Fetch relation reccord returnCode = example_relations_EXRELATP1_Fetch ( Format001.i_ContextRELATIE : EXORDRELRec.COMPANY : EXORDRELRec.RELATIONID ); if ( returnCode = RC_none ); returnCode = RC_skip; endif; return returnCode; end-proc; Contect inializeren dcl-s context like(tCX); dcl-s contextOrderRelation like(tCX); Dataformatter vervangen met de converter // Choose (and init) \"Data Formatter\" procedure to be used RC = example_relations_EXRELATD1_D002( context : DataVersion : DataSize/Count ); if ( RC <> RC_ok ); return; endif; if ( KeysDS.KeyChoice = SEARCH_BY_ORDER ); RC = Init_Context( contextOrderRelation : %paddr(AllocProc) ); if ( RC <> RC_ok ); return; endif; RC = example_relation_EXRELATC1_convertEXORDREL( contextOrderRelation : context ); if ( RC <> RC_ok ); return; endif; endif; Call naar de provider van de andere database structuur die dan fetch naar de db van de hoofd db // Actual \"business logic\" call(s) if ( KeysDS.KeyChoice = SEARCH_BY_RELATIONID ); exsr callEXRELATP1; elseif ( KeysDS.KeyChoice = SEARCH_BY_ORDER ); exsr callEXORDRELP1; ....... endif; // -- Internal subroutines -- // EXRELATP1 procedure calls begsr callEXORDRELP1; select; when ( OpCode = OC_list_pos ); RC = example_orderRelations_EXORDRELP1_Ascending ( contextOrderRelation : Count : 2 // frozen keys : 0 // summary keys : KeysDS.Company : KeysDS.Order ); when ( OpCode = OC_list_next ); RC = example_orderRelations_EXORDRELP1_Next( contextOrderRelation : Count ); when ( OpCode = OC_list_back ); RC = example_orderRelations_EXORDRELP1_Back( contextOrderRelation : Count ); when ( OpCode = OC_list_first ); RC = example_orderRelations_EXORDRELP1_First( contextOrderRelation : Count ); when ( OpCode = OC_list_last ); RC = example_orderRelations_EXORDRELP1_Last( contextOrderRelation : Count ); other; // Unsupported value found in parameter OpCode (&1). CXE0008.OpCode = OpCode; RC = SendMsg('CXE0008':CXE0008); endsl; endsr; Service Programma S 001 // -- Constant(s)- dcl-c INVOICE '003'; dcl-c CLOSED '4'; // ------------------------------ // -- Specific prototype(s) -- /include qcpylesrc,EXMORDS001 /include qcpylesrc,EXORDHDRU1 // ------------------------------ // Procedure for getting a count of order that needs to be payed dcl-proc Example_OrderRelations_EXMORDS001_CountNotPayed export; dcl-pi *n packed(3); i_Company like(EXORDRELL3Key.COMPANY) const; i_RelationId like(EXORDRELL3Key.RELATIONID) const; end-pi; // -- workfield(s) -- dcl-s count packed(3) inz(0); dcl-s status char(2); // -- Procedure logic -- // Count records that are on invoice and not closed EXORDRELL3Key.COMPANY = i_Company; EXORDRELL3Key.RELATIONID = i_RelationId; EXORDRELL3Key.ADDRESSTYP = INVOICE; setll %kds( EXORDRELL3Key : 3 ) EXORDRELL3; reade %kds( EXORDRELL3Key : 3 ) EXORDRELL3 EXORDRELL3Rec; dow ( not %eof ); status = Example_OrderDetail_EXORDHDRU1_GetStatus( i_Company : EXORDRELL3Rec.ORDER ); if ( status <> '' and status <> CLOSED ); count += 1; endif; reade %kds( EXORDRELL3Key : 3 ) EXORDRELL3 EXORDRELL3Rec; enddo; return count; end-proc; FileAcces U // ------------------------------- // Procedure for getting a status dcl-proc Example_OrderDetail_EXORDHDRU1_GetStatus export; dcl-pi *n like(EXORDHDRL1Rec.STATUS); i_Company like(EXORDHDRL1Key.COMPANY) const; i_Order like(EXORDHDRL1Key.ORDER) const; end-pi; // -- Procedure logic -- // Reset record and find record reset EXORDHDRL1Rec; EXORDHDRL1Key.COMPANY = i_Company; EXORDHDRL1Key.ORDER = i_Order; chain %kds( EXORDHDRL1Key : 2 ) EXORDHDRL1 EXORDHDRL1Rec; return EXORDHDRL1Rec.STATUS; end-proc; // ------------------------------- // Procedure for getting a unit of measurement dcl-proc Example_OrderDetail_EXORDDTLU1_GetUnitOfMeasurement export; dcl-pi *n like(EXORDDTLL1Rec.UOM); i_Company like(EXORDDTLL1Key.COMPANY) const; i_Order like(EXORDDTLL1Key.ORDER) const; end-pi; // -- Procedure logic -- // Reset record and find record reset EXORDDTLL1Rec; EXORDDTLL1Key.COMPANY = i_Company; EXORDDTLL1Key.ORDER = i_Order; chain %kds( EXORDDTLL1Key : 2 ) EXORDDTLL1 EXORDDTLL1Rec; return EXORDDTLL1Rec.UOM; end-proc; // Procedure for getting a count of orderDetails dcl-proc Example_OrderDetail_EXORDDTLU1_CountRecords export; dcl-pi *n packed(3); i_Company like(EXORDDTLL1Key.COMPANY) const; i_Order like(EXORDDTLL1Key.ORDER) const; end-pi; // -- workfield(s) -- dcl-s count packed(3) inz(0); // -- Procedure logic -- // Reset record and find record EXORDDTLL1Key.COMPANY = i_Company; EXORDDTLL1Key.ORDER = i_Order; setll %kds( EXORDDTLL1key : 2 ) EXORDDTLL1; reade %kds( EXORDDTLL1Key : 2 ) EXORDDTLL1 EXORDDTLL1Rec; dow ( not %eof ); count += 1; reade %kds( EXORDDTLL1Key : 2 ) EXORDDTLL1 EXORDDTLL1Rec; enddo; return count; end-proc; Get Read G Gewoon geneneren in xml // Get first record for given keys dcl-proc Example_OrderHeader_EXORDHDRG1_GetRead export; dcl-pi *n ind; i_Company like(EXORDHDRL1Key.COMPANY) const; i_Order like(EXORDHDRL1Key.ORDER) const options(*omit); io_Record char(1) options(*varsize); i_ForceRead ind const options(*nopass); end-pi; // -- Procedure logic -- // Lay record format over parameter \"io_Record\" ptr_EXORD = %addr(io_Record); // Save time when \"io_Record\" corresponds to the requested keys // We already have the record so no need to read again if ( not ( %parms = %parmnum(i_ForceRead) and i_ForceRead ) and EXORDHDRL1Rec.COMPANY = i_Company and ( %addr(i_Order) = *null or EXORDHDRL1Rec.ORDER = i_Order ) ); return *on; endif; // Read the record directly into \"io_Record\" EXORDHDRL1Key.COMPANY = i_Company; select; when ( %addr(i_Order) = *null ); chain %kds( EXORDHDRL1Key : 1 ) EXORDHDRL1 EXORDHDRL1Rec; other; EXORDHDRL1Key.ORDER = i_Order; chain %kds( EXORDHDRL1Key : 2 ) EXORDHDRL1 EXORDHDRL1Rec; endsl; if ( not %found ); clear EXORDHDRL1Rec; // This will clear the \"io_Record\" content endif; // Done return %found; end-proc; // ------------------------------------------------------------------------------------------------- // Get last record for given keys dcl-proc Example_OrderHeader_EXORDHDRG1_GetReadpe export; dcl-pi *n ind; i_Company like(EXORDHDRL1Key.COMPANY) const; i_Order like(EXORDHDRL1Key.ORDER) const options(*omit); io_Record char(1) options(*varsize); i_ForceRead ind const options(*nopass); end-pi; // -- Procedure logic -- // Lay record format over parameter \"io_Record\" ptr_EXORD = %addr(io_Record); // Save time when \"io_Record\" corresponds to the requested keys // We already have the record so no need to read again if ( not ( %parms = %parmnum(i_ForceRead) and i_ForceRead ) and EXORDHDRL1Rec.COMPANY = i_Company and ( %addr(i_Order) = *null or EXORDHDRL1Rec.ORDER = i_Order ) ); return *on; endif; // Read the record directly into \"io_Record\" EXORDHDRL1Key.COMPANY = i_Company; select; when ( %addr(i_Order) = *null ); setgt %kds( EXORDHDRL1Key : 1 ) EXORDHDRL1; readpe %kds( EXORDHDRL1Key : 1 ) EXORDHDRL1 EXORDHDRL1Rec; other; EXORDHDRL1Key.ORDER = i_Order; setgt %kds( EXORDHDRL1Key : 2 ) EXORDHDRL1; readpe %kds( EXORDHDRL1Key : 2 ) EXORDHDRL1 EXORDHDRL1Rec; endsl; if ( %eof ); clear EXORDHDRL1Rec; // This will clear the \"io_Record\" content endif; // Done return not %eof; end-proc;","title":"Example"},{"location":"rpgExample/#rpg-voorbeelden","text":"","title":"RPG Voorbeelden"},{"location":"rpgExample/#datatypes","text":"DCL-C Define a named constant DCL-DS Define a data structure END-DS End a data structure {DCL-PARM} Define a parameter DCL-PI Define a procedure interface (dcl-proc end-proc) END-PI End a procedure interface DCL-PR Define a prototype END-PR End a prototype DCL-S Define a standalone field {DCL-SUBF} Define a subfield","title":"DataTypes"},{"location":"rpgExample/#declaraties","text":"BINDEC(digits {: decimal-positions}) CHAR(length) DATE{(format{separator})} FLOAT(bytes) GRAPH(length) IND indicator(*on, *off) INT(digits) OBJECT{(*JAVA:class-name)} PACKED(digits {: decimal-positions}) gebruik dit boven digits , ditgits aleen als tijdelijke variabele (counter ...) POINTER{(*PROC)} TIME{(format{separator})} TIMESTAMP{(fractional-seconds)} UCS2(length) UNS(digits) VARCHAR(length {:2 | 4}) VARGRAPH(length {:2 | 4}) VARUCS2(length {:2 | 4}) ZONED(digits {: decimal-positions})","title":"Declaraties"},{"location":"rpgExample/#dataformatter-oproepen-met-extra-variable","text":"// Choose (and init) \"Data Formatter\" procedure to be used if (KeysDS.KeyChoice = SEARCH_BY_ORDERDATE); RC = Example_OrderHeader_EXORDHDRD1_D002 ( context : DataVersion : DataSize/Count : KeysDS.OrderDateTo ); else; RC = Example_OrderHeader_EXORDHDRD1_D002 ( context : DataVersion : DataSize/Count ); endif; if ( RC <> RC_ok ); return; endif; endif; dcl-ds Format002 qualified based(formatPointer); OrderDateTo packed(8); end-ds; parameter uit Lange call in datastructuur steken // Store the requested settings in the \"FormatData\" part of the \"context\" if ( %parms = %parmnum(i_OrderDateTo) ); Format002.OrderDateTo = CXDateTime_Date_To_Num(i_OrderDateTo); else; Format002.OrderDateTo = *hival; endif; // Check Date if ( EXORDHDRRec.ORDERDATE > Format002.OrderDateTo ); return RC_eof; endif;","title":"DataFormatter oproepen met extra variable"},{"location":"rpgExample/#zoeken-beginnen-met","text":"RC = Example_OrderHeader_EXORDHDRP1_Ascending ( context : Count : 2 // frozen keys : 0 // summary keys : KeysDS.Company : %trim(KeysDS.Order) + x'FF' ); endif;","title":"Zoeken beginnen met"},{"location":"rpgExample/#zoeken-op-dates","text":"RC = Example_OrderHeader_EXORDHDRP3_Ascending ( context : Count : 1 // frozen keys : 0 // summary keys : KeysDS.Company : CXDateTime_Date_To_Num(KeysDS.OrderDate) );","title":"Zoeken op Dates"},{"location":"rpgExample/#meerdere-zoektermen","text":"Keychoice dcl-ds KeysDS qualified based(keysPointer); KeyChoice packed(3); Company char(2); Order char(12); Carrier char(30); OrderDate date; OrderDateTo date; end-ds; select; when ( KeysDS.KeyChoice = SEARCH_BY_ORDER ); exsr callEXORDHDRP1; when ( KeysDS.KeyChoice = SEARCH_BY_CONTENT ); exsr callEXORDHDRP2; when ( KeysDS.KeyChoice = SEARCH_BY_ORDERDATE ); exsr callEXORDHDRP3; endsl;","title":"Meerdere zoektermen"},{"location":"rpgExample/#converter-c1","text":"Als je uit een record date moet halen voor een andere fetch uit te voeren op een andere database dcl-ds Format001 qualified based(formatPointer); i_ContextRELATIE like(tCX); end-ds; dcl-proc example_relation_EXRELATC1_convertEXORDREL export; dcl-pi *n like(tRC); io_Context like(tCX); i_ContextRELATIE const like(tCX); end-pi; // -- Procedure logic -- // Init formatter within the \"context\" of the caller if ( Init_Context_Format( io_Context : 0 : 0 : %size(Format001) : %paddr(convertEXORDREL) ) <> RC_ok ); // The \"DataFormat\" selection failed. Refer to the job log for more details. return SendMsg('CXE0029'); endif; // Activate \"context\" settings FormatPointer = Get_Context_FormatData( io_Context ); // Store the requested settings in the \"FormatData\" part of the \"context\" Format001.i_ContextRELATIE = i_ContextRELATIE; // Done return RC_ok; end-proc; // -- Internal procedures -- // This is the EXORDRELRC formatter dcl-proc convertEXORDREL; dcl-pi *n like(tRC); io_Context like(tCX); EXORDRELRec const likeds(tEXORDRELRec) options(*nopass); i_RemainingCount uns(5) const options(*nopass); o_Count uns(5) options(*nopass); end-pi; // -- The result set to be returned -- dcl-c MAX_COUNT const(1); // -- Workfields -- dcl-s returnCode like(tRC); // -- Procedure logic -- // Validate incoming context if ( Get_Context_FormatProc(io_Context) <> %paddr(convertEXORDREL) ); // The given \"context\" does not belong to the called procedure // Please contact the IT department. return SendMsg('CXE0010'); endif; // Init \"context\" for caller if ( %parms = %parmnum(io_Context) ); Set_Context_FormatDataID( io_Context : 0 : 0 ); return RC_none; endif; // Check remaining count if ( %parms = %parmnum(o_Count) and i_RemainingCount < MAX_COUNT ); o_Count = 0; return RC_more; endif; // Activate \"context\" settings formatPointer = Get_Context_FormatData( io_Context ); // Fetch relation reccord returnCode = example_relations_EXRELATP1_Fetch ( Format001.i_ContextRELATIE : EXORDRELRec.COMPANY : EXORDRELRec.RELATIONID ); if ( returnCode = RC_none ); returnCode = RC_skip; endif; return returnCode; end-proc; Contect inializeren dcl-s context like(tCX); dcl-s contextOrderRelation like(tCX); Dataformatter vervangen met de converter // Choose (and init) \"Data Formatter\" procedure to be used RC = example_relations_EXRELATD1_D002( context : DataVersion : DataSize/Count ); if ( RC <> RC_ok ); return; endif; if ( KeysDS.KeyChoice = SEARCH_BY_ORDER ); RC = Init_Context( contextOrderRelation : %paddr(AllocProc) ); if ( RC <> RC_ok ); return; endif; RC = example_relation_EXRELATC1_convertEXORDREL( contextOrderRelation : context ); if ( RC <> RC_ok ); return; endif; endif; Call naar de provider van de andere database structuur die dan fetch naar de db van de hoofd db // Actual \"business logic\" call(s) if ( KeysDS.KeyChoice = SEARCH_BY_RELATIONID ); exsr callEXRELATP1; elseif ( KeysDS.KeyChoice = SEARCH_BY_ORDER ); exsr callEXORDRELP1; ....... endif; // -- Internal subroutines -- // EXRELATP1 procedure calls begsr callEXORDRELP1; select; when ( OpCode = OC_list_pos ); RC = example_orderRelations_EXORDRELP1_Ascending ( contextOrderRelation : Count : 2 // frozen keys : 0 // summary keys : KeysDS.Company : KeysDS.Order ); when ( OpCode = OC_list_next ); RC = example_orderRelations_EXORDRELP1_Next( contextOrderRelation : Count ); when ( OpCode = OC_list_back ); RC = example_orderRelations_EXORDRELP1_Back( contextOrderRelation : Count ); when ( OpCode = OC_list_first ); RC = example_orderRelations_EXORDRELP1_First( contextOrderRelation : Count ); when ( OpCode = OC_list_last ); RC = example_orderRelations_EXORDRELP1_Last( contextOrderRelation : Count ); other; // Unsupported value found in parameter OpCode (&1). CXE0008.OpCode = OpCode; RC = SendMsg('CXE0008':CXE0008); endsl; endsr;","title":"Converter C1"},{"location":"rpgExample/#service-programma-s-001","text":"// -- Constant(s)- dcl-c INVOICE '003'; dcl-c CLOSED '4'; // ------------------------------ // -- Specific prototype(s) -- /include qcpylesrc,EXMORDS001 /include qcpylesrc,EXORDHDRU1 // ------------------------------ // Procedure for getting a count of order that needs to be payed dcl-proc Example_OrderRelations_EXMORDS001_CountNotPayed export; dcl-pi *n packed(3); i_Company like(EXORDRELL3Key.COMPANY) const; i_RelationId like(EXORDRELL3Key.RELATIONID) const; end-pi; // -- workfield(s) -- dcl-s count packed(3) inz(0); dcl-s status char(2); // -- Procedure logic -- // Count records that are on invoice and not closed EXORDRELL3Key.COMPANY = i_Company; EXORDRELL3Key.RELATIONID = i_RelationId; EXORDRELL3Key.ADDRESSTYP = INVOICE; setll %kds( EXORDRELL3Key : 3 ) EXORDRELL3; reade %kds( EXORDRELL3Key : 3 ) EXORDRELL3 EXORDRELL3Rec; dow ( not %eof ); status = Example_OrderDetail_EXORDHDRU1_GetStatus( i_Company : EXORDRELL3Rec.ORDER ); if ( status <> '' and status <> CLOSED ); count += 1; endif; reade %kds( EXORDRELL3Key : 3 ) EXORDRELL3 EXORDRELL3Rec; enddo; return count; end-proc;","title":"Service Programma S 001"},{"location":"rpgExample/#fileacces-u","text":"// ------------------------------- // Procedure for getting a status dcl-proc Example_OrderDetail_EXORDHDRU1_GetStatus export; dcl-pi *n like(EXORDHDRL1Rec.STATUS); i_Company like(EXORDHDRL1Key.COMPANY) const; i_Order like(EXORDHDRL1Key.ORDER) const; end-pi; // -- Procedure logic -- // Reset record and find record reset EXORDHDRL1Rec; EXORDHDRL1Key.COMPANY = i_Company; EXORDHDRL1Key.ORDER = i_Order; chain %kds( EXORDHDRL1Key : 2 ) EXORDHDRL1 EXORDHDRL1Rec; return EXORDHDRL1Rec.STATUS; end-proc; // ------------------------------- // Procedure for getting a unit of measurement dcl-proc Example_OrderDetail_EXORDDTLU1_GetUnitOfMeasurement export; dcl-pi *n like(EXORDDTLL1Rec.UOM); i_Company like(EXORDDTLL1Key.COMPANY) const; i_Order like(EXORDDTLL1Key.ORDER) const; end-pi; // -- Procedure logic -- // Reset record and find record reset EXORDDTLL1Rec; EXORDDTLL1Key.COMPANY = i_Company; EXORDDTLL1Key.ORDER = i_Order; chain %kds( EXORDDTLL1Key : 2 ) EXORDDTLL1 EXORDDTLL1Rec; return EXORDDTLL1Rec.UOM; end-proc; // Procedure for getting a count of orderDetails dcl-proc Example_OrderDetail_EXORDDTLU1_CountRecords export; dcl-pi *n packed(3); i_Company like(EXORDDTLL1Key.COMPANY) const; i_Order like(EXORDDTLL1Key.ORDER) const; end-pi; // -- workfield(s) -- dcl-s count packed(3) inz(0); // -- Procedure logic -- // Reset record and find record EXORDDTLL1Key.COMPANY = i_Company; EXORDDTLL1Key.ORDER = i_Order; setll %kds( EXORDDTLL1key : 2 ) EXORDDTLL1; reade %kds( EXORDDTLL1Key : 2 ) EXORDDTLL1 EXORDDTLL1Rec; dow ( not %eof ); count += 1; reade %kds( EXORDDTLL1Key : 2 ) EXORDDTLL1 EXORDDTLL1Rec; enddo; return count; end-proc;","title":"FileAcces U"},{"location":"rpgExample/#get-read-g","text":"Gewoon geneneren in xml // Get first record for given keys dcl-proc Example_OrderHeader_EXORDHDRG1_GetRead export; dcl-pi *n ind; i_Company like(EXORDHDRL1Key.COMPANY) const; i_Order like(EXORDHDRL1Key.ORDER) const options(*omit); io_Record char(1) options(*varsize); i_ForceRead ind const options(*nopass); end-pi; // -- Procedure logic -- // Lay record format over parameter \"io_Record\" ptr_EXORD = %addr(io_Record); // Save time when \"io_Record\" corresponds to the requested keys // We already have the record so no need to read again if ( not ( %parms = %parmnum(i_ForceRead) and i_ForceRead ) and EXORDHDRL1Rec.COMPANY = i_Company and ( %addr(i_Order) = *null or EXORDHDRL1Rec.ORDER = i_Order ) ); return *on; endif; // Read the record directly into \"io_Record\" EXORDHDRL1Key.COMPANY = i_Company; select; when ( %addr(i_Order) = *null ); chain %kds( EXORDHDRL1Key : 1 ) EXORDHDRL1 EXORDHDRL1Rec; other; EXORDHDRL1Key.ORDER = i_Order; chain %kds( EXORDHDRL1Key : 2 ) EXORDHDRL1 EXORDHDRL1Rec; endsl; if ( not %found ); clear EXORDHDRL1Rec; // This will clear the \"io_Record\" content endif; // Done return %found; end-proc; // ------------------------------------------------------------------------------------------------- // Get last record for given keys dcl-proc Example_OrderHeader_EXORDHDRG1_GetReadpe export; dcl-pi *n ind; i_Company like(EXORDHDRL1Key.COMPANY) const; i_Order like(EXORDHDRL1Key.ORDER) const options(*omit); io_Record char(1) options(*varsize); i_ForceRead ind const options(*nopass); end-pi; // -- Procedure logic -- // Lay record format over parameter \"io_Record\" ptr_EXORD = %addr(io_Record); // Save time when \"io_Record\" corresponds to the requested keys // We already have the record so no need to read again if ( not ( %parms = %parmnum(i_ForceRead) and i_ForceRead ) and EXORDHDRL1Rec.COMPANY = i_Company and ( %addr(i_Order) = *null or EXORDHDRL1Rec.ORDER = i_Order ) ); return *on; endif; // Read the record directly into \"io_Record\" EXORDHDRL1Key.COMPANY = i_Company; select; when ( %addr(i_Order) = *null ); setgt %kds( EXORDHDRL1Key : 1 ) EXORDHDRL1; readpe %kds( EXORDHDRL1Key : 1 ) EXORDHDRL1 EXORDHDRL1Rec; other; EXORDHDRL1Key.ORDER = i_Order; setgt %kds( EXORDHDRL1Key : 2 ) EXORDHDRL1; readpe %kds( EXORDHDRL1Key : 2 ) EXORDHDRL1 EXORDHDRL1Rec; endsl; if ( %eof ); clear EXORDHDRL1Rec; // This will clear the \"io_Record\" content endif; // Done return not %eof; end-proc;","title":"Get Read G"}]}